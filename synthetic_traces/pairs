import torch
from torch_geometric.data import Data
from collections import Counter
import os

"""
Reads messages from a specified file and organizes them into sections.
    Parameters:
    - file_path: Path to the file containing the messages.
    
    Returns:
    - messages: A list of messages, each represented as a tuple (index, src, dest).
    - sections: A list of sections, each containing a list of message strings.
    
"""
def read_messages_from_file(file_path):
    with open(file_path, 'r') as file:
        content = file.read().strip().split('#')
    sections = [section.strip().split('\n') for section in content if section.strip()]
    messages = []
    for section in sections:
        for line in section:
            if line:
                parts = line.split(':')
                index, src, dest = int(parts[0].strip()), parts[1].strip(), parts[2].strip()
                messages.append((index, src, dest))
    return messages, sections


"""
Constructs a causality graph from the given messages.
    
    Parameters:
    - messages: A list of messages, each represented as a tuple (index, src, dest).
    - sections: A list of sections from the file, used to determine initial and terminating nodes.
    
    Returns:
    - A Data object representing the graph, sets of initial and terminating nodes, and a dictionary of successors.
    """

def construct_causality_graph(messages, sections):
    edge_list = []
    initial_nodes = set(int(line.split(':')[0].strip()) for line in sections[0] if line)
    terminating_nodes = set(int(line.split(':')[0].strip()) for line in sections[-1] if line)
    successors_dict = {}  # Adjusted to hold more detailed info
    
    for index, src, dest in messages:
        if index not in successors_dict:
            successors_dict[index] = {'src': src, 'dest': dest, 'successors': []}
        for _, s, d in messages:
            if dest == s and index not in terminating_nodes and _ not in initial_nodes:
                edge_list.append((index, _))
                successors_dict[index]['successors'].append(_)
                if _ not in successors_dict:
                    successors_dict[_] = {'src': s, 'dest': d, 'successors': []}

    edge_index = torch.tensor(list(zip(*edge_list)), dtype=torch.long)
    return Data(edge_index=edge_index), initial_nodes, terminating_nodes, successors_dict


def get_successors(node_index, successors_dict):
    node_info = successors_dict.get(node_index)
    if node_info:
        successors_info = [(succ, successors_dict[succ]['src'], successors_dict[succ]['dest']) for succ in node_info['successors']]
        return successors_info
    return []

"""
Prints detailed path information for the successors of the specified node.
    
    Parameters:
    - node_index: The index of the node to query.
    - successors_dict: A dictionary mapping each node to its details and list of successors.
"""

def print_successor_info(node_index, successors_dict):

    if node_index in successors_dict:
        node_info = successors_dict[node_index]
        print(f"Node {node_index} (Source: {node_info['src']}, Destination: {node_info['dest']}) has successors:")
        for succ in node_info['successors']:
            succ_info = successors_dict.get(succ, {})
            print(f"  Successor: {succ}, Path: {succ_info.get('src', 'N/A')} -> {succ_info.get('dest', 'N/A')}")
    else:
        print(f"Node {node_index} has no successors or does not exist in the graph.")


"""
pass in two indices, and check if there is a connection in the graph.
"""
def isCausal(node_index1, node_index2, successors_dict):
    successors_of_node1 = successors_dict.get(node_index1, {}).get('successors', [])
    successors_of_node2 = successors_dict.get(node_index2, {}).get('successors', [])
    
    if node_index2 in successors_of_node1:
        return True
    return False

"""
print if 2 nodes are connected or not.
"""
def print_causality_info(node_index1, node_index2, successors_dict):
    successors_of_node1 = successors_dict.get(node_index1, {}).get('successors', [])
    successors_of_node2 = successors_dict.get(node_index2, {}).get('successors', [])
    
    if node_index1 in successors_of_node2:
        print(f"Node {node_index2} is causal to Node {node_index1}.")
    elif node_index2 in successors_of_node1:
        print(f"Node {node_index1} is causal to Node {node_index2}.")
    else:
        print(f"Nodes {node_index1} and {node_index2} are not connected.")


# Function to read trace from a file
def read_trace_from_file(file_path):
    with open(file_path, 'r') as file:
        trace = file.read().strip().split()
    return [int(index) for index in trace]


# Function to find all possible binary subsequences and filter out causal ones
def find_causal_binary_subsequences(trace, successors_dict):
    subsequences = [(trace[i], trace[i+1]) for i in range(len(trace) - 1)]
    causal_subsequences = [(index1, index2) for index1, index2 in subsequences if isCausal(index1, index2, successors_dict)]
    return causal_subsequences


def find_most_common_subsequences(subsequences, top_n=5):
    subsequence_counter = Counter(subsequences)
    return subsequence_counter.most_common(top_n)


def compute_common_causal_subsequences(folder_path, output_file, successors_dict):
    total_counter = Counter()

    for file_name in os.listdir(folder_path):
        if file_name.endswith(".txt"):
            file_path = os.path.join(folder_path, file_name)
            trace = read_trace_from_file(file_path)
            causal_subsequences = find_causal_binary_subsequences(trace, successors_dict)
            most_common_subsequences = find_most_common_subsequences(causal_subsequences)
            total_counter.update(dict(most_common_subsequences))

    with open(output_file, 'w') as f:
        for subsequence, count in total_counter.most_common():
            f.write(f"{subsequence[0]} {subsequence[1]} : {count}\n")

    print(f"Most common causal binary subsequences written to {output_file}")


if __name__ == "__main__":
    file_path = "synthetic_traces/newLarge.msg"  
    messages, sections = read_messages_from_file(file_path)
    data, initial_nodes, terminating_nodes, successors_dict = construct_causality_graph(messages, sections)

    



    folder_path = "synthetic_traces/traces/trace-small-5"  
    output_file = "synthetic_traces/traces/trace-small-5-common_subsequences.txt"
    compute_common_causal_subsequences(folder_path, output_file, successors_dict)

    folder_path = "synthetic_traces/traces/trace-small-10"  
    output_file = "synthetic_traces/traces/trace-small-10-common_subsequences.txt"
    compute_common_causal_subsequences(folder_path, output_file, successors_dict)

    folder_path = "synthetic_traces/traces/trace-small-20"  
    output_file = "synthetic_traces/traces/trace-small-20-common_subsequences.txt"
    compute_common_causal_subsequences(folder_path, output_file, successors_dict)


    folder_path = "synthetic_traces/traces/trace-large-5"  
    output_file = "synthetic_traces/traces/trace-large-5-common_subsequences.txt"
    compute_common_causal_subsequences(folder_path, output_file, successors_dict)

    folder_path = "synthetic_traces/traces/trace-large-10"  
    output_file = "synthetic_traces/traces/trace-large-10-common_subsequences.txt"
    compute_common_causal_subsequences(folder_path, output_file, successors_dict)

    folder_path = "synthetic_traces/traces/trace-large-20"  
    output_file = "synthetic_traces/traces/trace-large-20-common_subsequences.txt"
    compute_common_causal_subsequences(folder_path, output_file, successors_dict)

